---
# Ejemplo completo de una MT que verifica si una cadena es un palíndromo
q_states:
  q_list:
    - '0'
    - '1'
    - '2'
    - '3'
    - '4'
    - '5'
  initial: '0'
  final: '5'

alphabet:
  - a
  - b

tape_alphabet:
  - a
  - b
  - X
  - Y
  - null

delta:
  # Leer primer símbolo y marcarlo
  - params:
      initial_state: '0'
      mem_cache_value: null
      tape_input: a
    output:
      final_state: '1'
      mem_cache_value: a
      tape_output: X
      tape_displacement: R
  - params:
      initial_state: '0'
      mem_cache_value: null
      tape_input: b
    output:
      final_state: '1'
      mem_cache_value: b
      tape_output: X
      tape_displacement: R
  # Avanzar hasta el final
  - params:
      initial_state: '1'
      mem_cache_value: a
      tape_input: a
    output:
      final_state: '1'
      mem_cache_value: a
      tape_output: a
      tape_displacement: R
  - params:
      initial_state: '1'
      mem_cache_value: a
      tape_input: b
    output:
      final_state: '1'
      mem_cache_value: a
      tape_output: b
      tape_displacement: R
  - params:
      initial_state: '1'
      mem_cache_value: b
      tape_input: a
    output:
      final_state: '1'
      mem_cache_value: b
      tape_output: a
      tape_displacement: R
  - params:
      initial_state: '1'
      mem_cache_value: b
      tape_input: b
    output:
      final_state: '1'
      mem_cache_value: b
      tape_output: b
      tape_displacement: R
  # Llegar al blank, retroceder y verificar
  - params:
      initial_state: '1'
      mem_cache_value: a
      tape_input: null
    output:
      final_state: '2'
      mem_cache_value: a
      tape_output: null
      tape_displacement: L
  - params:
      initial_state: '1'
      mem_cache_value: b
      tape_input: null
    output:
      final_state: '2'
      mem_cache_value: b
      tape_output: null
      tape_displacement: L
  # Verificar último símbolo
  - params:
      initial_state: '2'
      mem_cache_value: a
      tape_input: a
    output:
      final_state: '3'
      mem_cache_value: null
      tape_output: Y
      tape_displacement: L
  - params:
      initial_state: '2'
      mem_cache_value: b
      tape_input: b
    output:
      final_state: '3'
      mem_cache_value: null
      tape_output: Y
      tape_displacement: L
  # Retroceder hasta encontrar X
  - params:
      initial_state: '3'
      mem_cache_value: null
      tape_input: a
    output:
      final_state: '3'
      mem_cache_value: null
      tape_output: a
      tape_displacement: L
  - params:
      initial_state: '3'
      mem_cache_value: null
      tape_input: b
    output:
      final_state: '3'
      mem_cache_value: null
      tape_output: b
      tape_displacement: L
  - params:
      initial_state: '3'
      mem_cache_value: null
      tape_input: Y
    output:
      final_state: '3'
      mem_cache_value: null
      tape_output: Y
      tape_displacement: L
  # Encontrar X, avanzar y repetir
  - params:
      initial_state: '3'
      mem_cache_value: null
      tape_input: X
    output:
      final_state: '1'
      mem_cache_value: null
      tape_output: X
      tape_displacement: R
  # Aceptar si encontramos blank después de X
  - params:
      initial_state: '1'
      mem_cache_value: null
      tape_input: null
    output:
      final_state: '5'
      mem_cache_value: null
      tape_output: null
      tape_displacement: S

simulation_strings:
  - abba
  - aba
  - ab


